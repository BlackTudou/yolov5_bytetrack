# 代码详细说明文档

## 1. 主程序 main.py 核心类

### SafetyDistanceMonitor 类

这是系统的核心控制器，负责协调所有模块。

#### 初始化方法

```python
def __init__(self, model_path, conf_threshold=0.25, min_distance=1.5,
             device='cpu', camera_id=0, img_size=1280):
```

**参数说明**：
- `model_path`: YOLOv5s 模型文件路径
- `conf_threshold`: 检测置信度阈值（0-1）
- `min_distance`: 最小安全距离（米）
- `device`: 运行设备 'cpu' 或 'cuda'
- `camera_id`: 摄像头ID
- `img_size`: 输入图像尺寸（640/1280/1920）

#### 核心方法

##### 1. detect_objects()
```python
def detect_objects(self, img):
    """检测图像中的人员"""
    # 调用检测器进行推理
    detections = self.detector.detect(img, conf_threshold=self.conf_threshold)
    return detections
```
**功能**：调用 YOLOv5s 检测人员
**返回**：检测结果列表 `[[tlwh, score, class_id], ...]`

##### 2. calculate_distance()
```python
def calculate_distance(self, person1, person2) -> Tuple[float, float]:
    """计算两人之间的真实距离"""
    # 1. 计算像素距离
    # 2. 估算两人深度
    # 3. 转换为真实距离
    return pixel_dist, real_dist
```
**功能**：计算两个跟踪对象之间的真实世界距离
**返回**：`(像素距离, 真实距离米)`

##### 3. detect_violations()
```python
def detect_violations(self, tracked_objects):
    """检测安全距离违规"""
    violations = []
    for i, person1 in enumerate(tracked_objects):
        for j, person2 in enumerate(tracked_objects):
            if i >= j:  # 避免重复对
                continue
            _, real_dist = self.calculate_distance(person1, person2)
            if real_dist < self.min_distance:
                violations.append((person1.track_id, person2.track_id, real_dist))
    return violations
```
**功能**：检测所有人员对的距离违规
**返回**：违规列表 `[(id1, id2, distance), ...]`

## 2. 检测模块 detection.py

### YOLOv5Detector 类

#### 加载模型
```python
def _load_model(self):
    """三种方法加载模型"""
    try:
        # 方法1：尝试加载本地模型
        checkpoint = torch.load(model_path, weights_only=False)
        self.model = checkpoint
    except:
        # 方法2：从torch.hub下载
        self.model = torch.hub.load('ultralytics/yolov5', 'yolov5s')
    except:
        # 方法3：使用旧方法
        checkpoint = torch.load(model_path)
```
**特点**：多级回退策略，确保模型加载成功

#### 检测流程
```python
def detect(self, img, conf_threshold=0.5):
    """检测人员"""
    # 1. 预处理
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

    # 2. 推理
    results = self.model(img_rgb, size=640)

    # 3. 解析结果
    if hasattr(results, 'pandas'):
        # YOLOv5 v5+ 格式
        df = results.pandas().xyxy[0]
        for row in df.iterrows():
            if row['confidence'] > conf_threshold and row['class'] == 0:
                detections.append([tlwh, score, 0])

    return detections
```

## 3. 跟踪模块 tracker.py

### ByteTracker 类

#### 核心算法流程

```python
def update(self, detections, frame_id):
    """更新跟踪"""
    # 步骤1：分离置信度
    detections_high = [d for d in detections if d.score >= 0.6]
    detections_low = [d for d in detections if 0.5 <= d.score < 0.6]

    # 步骤2：关联已跟踪
    tracked, unmatched_tracks = associate_detections_to_trackers(
        tracked_stracks, detections_high)

    # 步骤3：更新匹配的轨迹
    for track_idx, det_idx in tracked:
        tracked_stracks[track_idx].update(detections_high[det_idx])

    # 步骤4：重新激活丢失轨迹
    reactivated, _ = associate_detections_to_trackers(
        lost_stracks, detections_high)

    # 步骤5：创建新轨迹
    for unmatched_det in unmatched_high_confs:
        create_new_track(unmatched_det)

    return active_tracks
```

### STrack 类（单个跟踪对象）

```python
class STrack:
    def __init__(self, tlwh, score, cls_id):
        self.tlwh = np.asarray(tlwh)  # 边界框
        self.score = score            # 置信度
        self.track_id = 0             # ID（待分配）
        self.state = 'New'            # 状态
        self.mean = ...               # 卡尔曼滤波状态

    def activate(self, frame_id, track_id):
        """激活轨迹"""
        self.track_id = track_id
        self.frame_id = frame_id
        self.state = 'Tracked'
        self.is_activated = True

    def re_activate(self, new_track, frame_id, new_id=False):
        """重新激活丢失的轨迹"""
        self.track_id = new_id if new_id else self.track_id
        self.update(new_track, frame_id)
        self.state = 'Tracked'

    def mark_lost(self):
        """标记为丢失"""
        self.state = 'Lost'

    def mark_removed(self):
        """标记为移除"""
        self.state = 'Removed'
```

## 4. 标定模块 camera_calibrate.py

### CameraCalibrator 类

#### 距离估算（改进版）

```python
def estimate_distance(self, pixel_width, pixel_height):
    """估算人员与相机的距离"""

    # 方法1：基于高度（更稳定）
    distance_by_height = (self.person_height * self.focal_length) / pixel_height

    # 方法2：基于宽度
    distance_by_width = (self.person_width * self.focal_length) / pixel_width

    # 透视校正
    if distance_by_height > 2.0:
        distance_by_height *= 1.1

    # 方差修正
    if abs(distance_by_width - distance_by_height) > 0.5:
        distance_by_width = distance_by_height

    # 加权平均（70%高度，30%宽度）
    estimated = 0.7 * distance_by_height + 0.3 * distance_by_width

    return clamp(estimated, 1.0, 8.0)
```

#### 像素转真实距离

```python
def pixel_to_real_distance(self, pixel_distance, avg_object_distance=2.0):
    """将像素距离转换为真实世界距离"""

    # 计算角度
    angular_distance = pixel_distance / self.focal_length

    # 转换为米
    real_distance = angular_distance * avg_object_distance

    # 透视校正
    if avg_object_distance < 2.0:
        real_distance *= 0.85  # 近距离
    elif avg_object_distance > 4.0:
        real_distance *= 1.05  # 远距离

    return real_distance
```

## 5. 关键数据结构

### 5.1 检测结果格式
```python
detection = [tlwh, score, class_id]
# tlwh: [x, y, width, height]  # top-left width height
# score: float  # 置信度
# class_id: int  # 0=person
```

### 5.2 跟踪对象
```python
track = {
    'tlwh': [x, y, w, h],    # 边界框
    'track_id': int,         # 唯一ID
    'score': float,          # 置信度
    'state': str,            # 'Tracked'/'Lost'/'Removed'
    'frame_id': int,         # 帧ID
    'track_len': int         # 轨迹长度
}
```

### 5.3 违规信息
```python
violation = (track_id1, track_id2, real_distance)
# 例如：(1, 2, 1.2)  # ID1和ID2相距1.2米
```

## 6. 数据流向图

```
原始视频帧 (BGR)
    ↓
RGB转换
    ↓
预处理 (resize, normalize)
    ↓
YOLOv5s检测
    ↓
检测结果: [[tlwh, score, 0], ...]
    ↓
ByteTrack跟踪
    ↓
跟踪结果: [STrack, STrack, ...] (带track_id)
    ↓
距离计算: [(id1, id2, dist), ...]
    ↓
违规检测: violations
    ↓
可视化: 绘制边界框、ID、连线
    ↓
显示在窗口/保存图片
```

## 7. 关键配置参数

### 7.1 检测参数
```python
conf_threshold = 0.25  # 检测置信度阈值
img_size = 1280        # 输入图像尺寸
```

### 7.2 跟踪参数
```python
high_thresh = 0.6      # 高置信度阈值
match_thresh = 0.8     # IoU匹配阈值
track_buffer = 30      # 轨迹缓冲区
```

### 7.3 标定参数
```python
focal_length = 1536    # 焦距（自动计算）
person_height = 1.65   # 平均身高（米）
person_width = 0.45    # 平均肩宽（米）
min_distance = 1.5     # 最小安全距离（米）
```

## 8. 性能优化点

### 8.1 检测优化
- 使用GPU加速
- 批量处理
- 自适应输入尺寸

### 8.2 跟踪优化
- IoU缓存
- 只处理激活轨迹
- 限制缓冲区大小

### 8.3 距离计算优化
- 加权平均（减少异常值）
- 透视校正（考虑距离）
- 方差修正（过滤异常估计）

